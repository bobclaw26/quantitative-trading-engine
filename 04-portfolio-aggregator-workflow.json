{
  "name": "Quantitative Trading Engine - Portfolio Aggregator",
  "nodes": [
    {
      "name": "Trigger - Every Hour",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [0, 0],
      "parameters": {
        "cronExpression": "0 * * * *",
        "timezone": "UTC"
      }
    },
    {
      "name": "Load All Positions",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 0],
      "parameters": {
        "dataTableName": "paper_positions",
        "mode": "select"
      }
    },
    {
      "name": "Load Trade History",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 100],
      "parameters": {
        "dataTableName": "trade_log",
        "mode": "select",
        "orderBy": "timestamp DESC",
        "limit": 1000
      }
    },
    {
      "name": "Calculate Portfolio Metrics",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 0],
      "parameters": {
        "functionCode": "const positions = items[0]?.json ? [items[0].json] : []; const trades = items[1]?.json ? [items[1].json] : []; const initial_capital = 100000; let total_unrealized_pnl = 0; let portfolio_values = [initial_capital]; positions.forEach(pos => {if (pos.quantity && pos.quantity !== 0 && !pos.symbol?.includes('_CLOSED')) {total_unrealized_pnl += pos.unrealized_pnl || 0}}); let realized_pnl = 0; const buyTrades = {}; trades.forEach(trade => {if (trade.side === 'BUY') {if (!buyTrades[trade.symbol]) buyTrades[trade.symbol] = []; buyTrades[trade.symbol].push(trade)} else if (trade.side === 'SELL') {if (buyTrades[trade.symbol] && buyTrades[trade.symbol].length > 0) {const matchTrade = buyTrades[trade.symbol].shift(); const pnl = (trade.price - matchTrade.price) * trade.quantity; realized_pnl += pnl}}}); const total_portfolio_value = initial_capital + realized_pnl + total_unrealized_pnl; let max_drawdown = 0; let peak = initial_capital; portfolio_values.concat(total_portfolio_value).forEach(val => {peak = Math.max(peak, val); const drawdown = (val - peak) / peak; max_drawdown = Math.min(max_drawdown, drawdown)}); const returns = []; for (let i = 1; i < portfolio_values.length; i++) {returns.push((portfolio_values[i] - portfolio_values[i-1]) / portfolio_values[i-1])}; const mean_return = returns.length > 0 ? returns.reduce((a,b) => a+b) / returns.length : 0; const variance = returns.length > 0 ? returns.reduce((sq, r) => sq + Math.pow(r - mean_return, 2), 0) / returns.length : 0; const std_dev = Math.sqrt(variance); const sharpe_ratio = std_dev > 0 ? (mean_return / std_dev) * Math.sqrt(252) : 0; const winningTrades = trades.filter(t => t.pnl > 0).length; const totalTrades = trades.filter(t => t.side === 'SELL').length; const win_rate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0; const cagr = ((total_portfolio_value - initial_capital) / initial_capital) * 100; return [{json: {total_portfolio_value: Math.round(total_portfolio_value * 100) / 100, total_unrealized_pnl: Math.round(total_unrealized_pnl * 100) / 100, realized_pnl: Math.round(realized_pnl * 100) / 100, sharpe_ratio: Math.round(sharpe_ratio * 100) / 100, max_drawdown: Math.round(max_drawdown * 10000) / 100, win_rate: Math.round(win_rate * 100) / 100, cagr: Math.round(cagr * 100) / 100, num_positions: positions.filter(p => p.quantity && p.quantity !== 0 && !p.symbol?.includes('_CLOSED')).length, num_trades: totalTrades, timestamp: new Date().toISOString()}}];"
      }
    },
    {
      "name": "Insert Portfolio Summary",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [600, 0],
      "parameters": {
        "dataTableName": "portfolio_summary",
        "mode": "insert",
        "columns": ["total_portfolio_value", "total_unrealized_pnl", "realized_pnl", "sharpe_ratio", "max_drawdown", "win_rate", "cagr", "num_positions", "num_trades", "timestamp"]
      }
    },
    {
      "name": "Calculate Strategy Breakdown",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 150],
      "parameters": {
        "functionCode": "const positions = items[0]?.json ? [items[0].json] : []; const breakdown = {}; positions.forEach(pos => {const strategy = pos.strategy_type || 'unknown'; if (!breakdown[strategy]) {breakdown[strategy] = {count: 0, total_value: 0, total_unrealized_pnl: 0}}; breakdown[strategy].count += 1; breakdown[strategy].total_value += pos.position_value || 0; breakdown[strategy].total_unrealized_pnl += pos.unrealized_pnl || 0}); return Object.keys(breakdown).map(strategy => ({json: {strategy_type: strategy, num_positions: breakdown[strategy].count, total_position_value: Math.round(breakdown[strategy].total_value * 100) / 100, total_unrealized_pnl: Math.round(breakdown[strategy].total_unrealized_pnl * 100) / 100, timestamp: new Date().toISOString()}}));"
      }
    },
    {
      "name": "Insert Strategy Breakdown",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [600, 150],
      "parameters": {
        "dataTableName": "strategy_breakdown",
        "mode": "insert",
        "columns": ["strategy_type", "num_positions", "total_position_value", "total_unrealized_pnl", "timestamp"]
      }
    }
  ],
  "connections": {
    "Trigger - Every Hour": {
      "main": [[{"node": "Load All Positions", "branch": 0, "index": 0}, {"node": "Load Trade History", "branch": 0, "index": 0}]]
    },
    "Load All Positions": {
      "main": [[{"node": "Calculate Portfolio Metrics", "branch": 0, "index": 0}, {"node": "Calculate Strategy Breakdown", "branch": 0, "index": 0}]]
    },
    "Load Trade History": {
      "main": [[{"node": "Calculate Portfolio Metrics", "branch": 0, "index": 1}]]
    },
    "Calculate Portfolio Metrics": {
      "main": [[{"node": "Insert Portfolio Summary", "branch": 0, "index": 0}]]
    },
    "Calculate Strategy Breakdown": {
      "main": [[{"node": "Insert Strategy Breakdown", "branch": 0, "index": 0}]]
    }
  },
  "settings": {
    "saveExecutionProgress": true
  },
  "active": false
}
