{
  "name": "Quantitative Trading Engine - Portfolio Aggregator",
  "nodes": [
    {
      "name": "Trigger - Every Hour",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [0, 0],
      "parameters": {
        "cronExpression": "0 * * * *",
        "timezone": "UTC"
      }
    },
    {
      "name": "Load All Positions",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 0],
      "parameters": {
        "dataTableName": "paper_positions",
        "mode": "select"
      }
    },
    {
      "name": "Load Trade History",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 100],
      "parameters": {
        "dataTableName": "trade_log",
        "mode": "select",
        "orderBy": "timestamp DESC",
        "limit": 1000
      }
    },
    {
      "name": "Calculate Portfolio Metrics",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 50],
      "parameters": {
        "functionCode": "const positions = items[0]?.json ? [items[0].json] : [];\nconst trades = items[1]?.json ? [items[1].json] : [];\nconst initial_capital = 100000;\nlet total_unrealized_pnl = 0;\nlet portfolio_values = [initial_capital];\npositions.forEach(pos => {\n  if (pos.quantity && pos.quantity !== 0 && !pos.symbol?.includes('_CLOSED')) {\n    total_unrealized_pnl += pos.unrealized_pnl || 0;\n  }\n});\nlet realized_pnl = 0;\nconst buyTrades = {};\ntrades.forEach(trade => {\n  if (trade.side === 'BUY') {\n    if (!buyTrades[trade.symbol]) buyTrades[trade.symbol] = [];\n    buyTrades[trade.symbol].push(trade);\n  } else if (trade.side === 'SELL') {\n    if (buyTrades[trade.symbol] && buyTrades[trade.symbol].length > 0) {\n      const matchTrade = buyTrades[trade.symbol].shift();\n      const pnl = (trade.price - matchTrade.price) * trade.quantity;\n      realized_pnl += pnl;\n    }\n  }\n});\nconst total_portfolio_value = initial_capital + realized_pnl + total_unrealized_pnl;\nlet max_drawdown = 0;\nlet peak = initial_capital;\nportfolio_values.concat(total_portfolio_value).forEach(val => {\n  peak = Math.max(peak, val);\n  const drawdown = (val - peak) / peak;\n  max_drawdown = Math.min(max_drawdown, drawdown);\n});\nconst returns = [];\nfor (let i = 1; i < portfolio_values.length; i++) {\n  returns.push((portfolio_values[i] - portfolio_values[i-1]) / portfolio_values[i-1]);\n}\nconst mean_return = returns.length > 0 ? returns.reduce((a,b) => a+b) / returns.length : 0;\nconst variance = returns.length > 0 ? returns.reduce((sq, r) => sq + Math.pow(r - mean_return, 2), 0) / returns.length : 0;\nconst std_dev = Math.sqrt(variance);\nconst sharpe_ratio = std_dev > 0 ? (mean_return / std_dev) * Math.sqrt(252) : 0;\nconst winningTrades = trades.filter(t => t.pnl > 0).length;\nconst totalTrades = trades.filter(t => t.side === 'SELL').length;\nconst win_rate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;\nconst cagr = ((total_portfolio_value - initial_capital) / initial_capital) * 100;\nreturn [{json: {total_portfolio_value: Math.round(total_portfolio_value * 100) / 100, total_unrealized_pnl: Math.round(total_unrealized_pnl * 100) / 100, realized_pnl: Math.round(realized_pnl * 100) / 100, sharpe_ratio: Math.round(sharpe_ratio * 100) / 100, max_drawdown: Math.round(max_drawdown * 10000) / 100, win_rate: Math.round(win_rate * 100) / 100, cagr: Math.round(cagr * 100) / 100, num_positions: positions.filter(p => p.quantity && p.quantity !== 0 && !p.symbol?.includes('_CLOSED')).length, num_trades: totalTrades, timestamp: new Date().toISOString()}}];"
      }
    },
    {
      "name": "Insert Portfolio Summary",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [600, 50],
      "parameters": {
        "dataTableName": "portfolio_summary",
        "mode": "insert",
        "columns": ["total_portfolio_value", "total_unrealized_pnl", "realized_pnl", "sharpe_ratio", "max_drawdown", "win_rate", "cagr", "num_positions", "num_trades", "timestamp"]
      }
    },
    {
      "name": "Calculate Strategy Breakdown",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 200],
      "parameters": {
        "functionCode": "const positions = items[0]?.json ? [items[0].json] : [];\nconst breakdown = {};\npositions.forEach(pos => {\n  const strategy = pos.strategy_type || 'unknown';\n  if (!breakdown[strategy]) {\n    breakdown[strategy] = { count: 0, total_value: 0, total_unrealized_pnl: 0 };\n  }\n  breakdown[strategy].count += 1;\n  breakdown[strategy].total_value += pos.position_value || 0;\n  breakdown[strategy].total_unrealized_pnl += pos.unrealized_pnl || 0;\n});\nreturn Object.keys(breakdown).map(strategy => ({json: {strategy_type: strategy, num_positions: breakdown[strategy].count, total_position_value: Math.round(breakdown[strategy].total_value * 100) / 100, total_unrealized_pnl: Math.round(breakdown[strategy].total_unrealized_pnl * 100) / 100, timestamp: new Date().toISOString()}}));"
      }
    },
    {
      "name": "Insert Strategy Breakdown",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [600, 200],
      "parameters": {
        "dataTableName": "strategy_breakdown",
        "mode": "insert",
        "columns": ["strategy_type", "num_positions", "total_position_value", "total_unrealized_pnl", "timestamp"]
      }
    }
  ],
  "connections": {
    "Trigger - Every Hour": {
      "main": [[{ "node": "Load All Positions", "branch": 0, "index": 0 }, { "node": "Load Trade History", "branch": 0, "index": 0 }]]
    },
    "Load All Positions": {
      "main": [[{ "node": "Calculate Portfolio Metrics", "branch": 0, "index": 0 }, { "node": "Calculate Strategy Breakdown", "branch": 0, "index": 0 }]]
    },
    "Load Trade History": {
      "main": [[{ "node": "Calculate Portfolio Metrics", "branch": 0, "index": 0 }]]
    },
    "Calculate Portfolio Metrics": {
      "main": [[{ "node": "Insert Portfolio Summary", "branch": 0, "index": 0 }]]
    },
    "Calculate Strategy Breakdown": {
      "main": [[{ "node": "Insert Strategy Breakdown", "branch": 0, "index": 0 }]]
    }
  },
  "settings": {
    "saveExecutionProgress": true\n  },\n  "active": false\n}\n"
      }
    }
  ]
}
