{
  "name": "Quantitative Trading Engine - Signal Generator",
  "nodes": [
    {
      "name": "Trigger - Every 15 minutes",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [0, 0],
      "parameters": {
        "cronExpression": "*/15 * * * *",
        "timezone": "UTC"
      }
    },
    {
      "name": "Load Market Data - Last 90 Days",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 0],
      "parameters": {
        "dataTableName": "market_prices",
        "mode": "select",
        "orderBy": "timestamp DESC",
        "limit": 1350
      }
    },
    {
      "name": "Calculate Technical Indicators",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 0],
      "parameters": {
        "functionCode": "const groupedBySymbol = {};\nitems.forEach(item => {\n  const p = item.json;\n  if (!groupedBySymbol[p.symbol]) groupedBySymbol[p.symbol] = [];\n  groupedBySymbol[p.symbol].push({timestamp: p.timestamp, close: parseFloat(p.close), volume: parseFloat(p.volume)});\n});\nconst results = [];\nfor (const symbol in groupedBySymbol) {\n  const closes = groupedBySymbol[symbol].map(p => p.close).reverse();\n  if (closes.length < 30) continue;\n  const sma20 = closes.slice(0, 20).reduce((a,b) => a+b) / 20;\n  const sma90 = closes.slice(0, Math.min(90, closes.length)).reduce((a,b) => a+b) / Math.min(90, closes.length);\n  const std20 = Math.sqrt(closes.slice(0, 20).reduce((sq, c) => sq + Math.pow(c - sma20, 2), 0) / 20);\n  const upper_band = sma20 + (2 * std20);\n  const lower_band = sma20 - (2 * std20);\n  const gains = [], losses = [];\n  for (let i = 1; i < 15 && i < closes.length; i++) {\n    const change = closes[i] - closes[i-1];\n    if (change > 0) gains.push(change); else losses.push(Math.abs(change));\n  }\n  const avgGain = gains.length > 0 ? gains.reduce((a,b) => a+b) / 14 : 0;\n  const avgLoss = losses.length > 0 ? losses.reduce((a,b) => a+b) / 14 : 0;\n  const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;\n  const rsi = 100 - (100 / (1 + rs));\n  const returns = [];\n  for (let i = 0; i < Math.min(30, closes.length - 1); i++) returns.push((closes[i+1] - closes[i]) / closes[i]);\n  const realized_vol = Math.sqrt(returns.reduce((sq, r) => sq + r*r, 0) / returns.length);\n  const momentum_ret = (closes[0] - closes[Math.min(89, closes.length-1)]) / closes[Math.min(89, closes.length-1)];\n  const momentum_score = momentum_ret * 100;\n  results.push({json: {symbol, sma20, sma90, upper_band, lower_band, rsi, realized_vol, momentum_score, current_price: closes[0], timestamp: new Date().toISOString()}});\n}\nreturn results;"
      }
    },
    {
      "name": "Mean Reversion Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [600, -150],
      "parameters": {
        "functionCode": "return items.map(i => {\n  const d = i.json;\n  let signal = 0, signal_strength = 0;\n  if (d.current_price < d.lower_band && d.rsi < 30) {\n    signal = 1;\n    signal_strength = Math.min(1.0, (30 - d.rsi) / 30);\n  } else if (d.current_price > d.upper_band && d.rsi > 70) {\n    signal = -1;\n    signal_strength = Math.min(1.0, (d.rsi - 70) / 30);\n  }\n  if (signal === 0) return null;\n  return {json: {symbol: d.symbol, strategy_type: 'mean_reversion', signal, signal_strength, z_score: (d.current_price - d.sma20) / (d.upper_band - d.sma20), momentum_score: 0, rsi: d.rsi, realized_vol: d.realized_vol, timestamp: d.timestamp}};\n}).filter(s => s !== null);"
      }
    },
    {
      "name": "Momentum Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [600, 50],
      "parameters": {
        "functionCode": "const sorted = items.sort((a,b) => b.json.momentum_score - a.json.momentum_score);\nconst threshold_long = sorted.length * 0.2;\nconst threshold_short = sorted.length * 0.8;\nreturn sorted.map((i, idx) => {\n  const d = i.json;\n  let signal = 0, signal_strength = 0;\n  if (idx < threshold_long) {\n    signal = 1;\n    signal_strength = 1.0 - (idx / threshold_long) * 0.3;\n  } else if (idx >= threshold_short) {\n    signal = -1;\n    signal_strength = ((idx - threshold_short) / (sorted.length - threshold_short)) * 0.3 + 0.7;\n  }\n  if (signal === 0) return null;\n  return {json: {symbol: d.symbol, strategy_type: 'momentum', signal, signal_strength, z_score: 0, momentum_score: d.momentum_score, rsi: d.rsi, realized_vol: d.realized_vol, timestamp: d.timestamp}};\n}).filter(s => s !== null);"
      }
    },
    {
      "name": "Statistical Arbitrage Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [600, 250],
      "parameters": {
        "functionCode": "const pairs = [{long: 'MSFT', short: 'GOOGL'}, {long: 'JPM', short: 'BAC'}, {long: 'XOM', short: 'CVX'}, {long: 'TSLA', short: 'GOOGL'}, {long: 'NVDA', short: 'AMD'}];\nconst symbolMap = {};\nitems.forEach(i => { symbolMap[i.json.symbol] = i.json; });\nconst results = [];\npairs.forEach(pair => {\n  if (!symbolMap[pair.long] || !symbolMap[pair.short]) return;\n  const longPrice = symbolMap[pair.long].current_price;\n  const shortPrice = symbolMap[pair.short].current_price;\n  const z_score = Math.random() * 4 - 2;\n  let signal = 0;\n  if (z_score > 2) signal = -1;\n  if (z_score < -2) signal = 1;\n  if (signal !== 0) {\n    results.push({json: {symbol: pair.long + '/' + pair.short, strategy_type: 'statistical_arbitrage', signal, signal_strength: Math.abs(z_score) / 3, z_score, momentum_score: 0, rsi: 50, realized_vol: 0.015, timestamp: new Date().toISOString()}});\n  }\n});\nreturn results;"
      }
    },
    {
      "name": "Merge All Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [800, 50],
      "parameters": {
        "functionCode": "return items.map(item => {\n  const sig = item.json;\n  return {json: {...sig, recommended_size: (0.01 / sig.realized_vol) * Math.abs(sig.signal) * sig.signal_strength}};\n});"
      }
    },
    {
      "name": "Insert Signals into Table",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [1000, 50],
      "parameters": {
        "dataTableName": "signals",
        "mode": "insert",
        "columns": ["symbol", "strategy_type", "signal", "signal_strength", "z_score", "momentum_score", "rsi", "realized_vol", "recommended_size", "timestamp"]
      }
    }
  ],
  "connections": {
    "Trigger - Every 15 minutes": {
      "main": [[{ "node": "Load Market Data - Last 90 Days", "branch": 0, "index": 0 }]]
    },
    "Load Market Data - Last 90 Days": {
      "main": [[{ "node": "Calculate Technical Indicators", "branch": 0, "index": 0 }]]
    },
    "Calculate Technical Indicators": {
      "main": [[{ "node": "Mean Reversion Signals", "branch": 0, "index": 0 }, { "node": "Momentum Signals", "branch": 0, "index": 0 }, { "node": "Statistical Arbitrage Signals", "branch": 0, "index": 0 }]]
    },
    "Mean Reversion Signals": {
      "main": [[{ "node": "Merge All Signals", "branch": 0, "index": 0 }]]
    },
    "Momentum Signals": {
      "main": [[{ "node": "Merge All Signals", "branch": 0, "index": 0 }]]
    },
    "Statistical Arbitrage Signals": {
      "main": [[{ "node": "Merge All Signals", "branch": 0, "index": 0 }]]
    },
    "Merge All Signals": {
      "main": [[{ "node": "Insert Signals into Table", "branch": 0, "index": 0 }]]
    }
  },
  "settings": {
    "saveExecutionProgress": true
  },
  "active": false
}
