{
  "name": "Quantitative Trading Engine - Signal Generator",
  "nodes": [
    {
      "name": "Trigger - Every 15 minutes",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [0, 0],
      "parameters": {
        "cronExpression": "*/15 * * * *",
        "timezone": "UTC"
      }
    },
    {
      "name": "Collect Market Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [200, 0],
      "parameters": {
        "functionCode": "const mockData = [{symbol: 'AAPL', close: 150, volume: 1000000}, {symbol: 'MSFT', close: 310, volume: 800000}, {symbol: 'GOOGL', close: 140, volume: 600000}]; return mockData.map(d => ({json: {symbol: d.symbol, timestamp: new Date().toISOString(), close: d.close, volume: d.volume, sma20: d.close * 0.98, sma90: d.close * 0.95, rsi: 50, realized_vol: 0.02, momentum_score: Math.random() * 10 - 5}}));"
      }
    },
    {
      "name": "Mean Reversion Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, -100],
      "parameters": {
        "functionCode": "return items.map(i => {const d = i.json; const upper_band = d.sma20 * 1.05; const lower_band = d.sma20 * 0.95; let signal = 0, signal_strength = 0; if (d.close < lower_band && d.rsi < 30) {signal = 1; signal_strength = 0.8} else if (d.close > upper_band && d.rsi > 70) {signal = -1; signal_strength = 0.7}; if (signal === 0) return null; return {json: {symbol: d.symbol, strategy_type: 'mean_reversion', signal, signal_strength, z_score: 0, momentum_score: 0, rsi: d.rsi, realized_vol: d.realized_vol, timestamp: d.timestamp}};}).filter(s => s !== null);"
      }
    },
    {
      "name": "Momentum Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 50],
      "parameters": {
        "functionCode": "const sorted = items.sort((a,b) => b.json.momentum_score - a.json.momentum_score); const threshold_long = Math.ceil(sorted.length * 0.2); return sorted.map((i, idx) => {const d = i.json; let signal = 0, signal_strength = 0; if (idx < threshold_long) {signal = 1; signal_strength = 0.9} else if (idx >= sorted.length - threshold_long) {signal = -1; signal_strength = 0.8}; if (signal === 0) return null; return {json: {symbol: d.symbol, strategy_type: 'momentum', signal, signal_strength, z_score: 0, momentum_score: d.momentum_score, rsi: d.rsi, realized_vol: d.realized_vol, timestamp: d.timestamp}};}).filter(s => s !== null);"
      }
    },
    {
      "name": "Statistical Arbitrage Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 200],
      "parameters": {
        "functionCode": "const pairs = [{long: 'MSFT', short: 'GOOGL'}, {long: 'JPM', short: 'BAC'}]; const symbolMap = {}; items.forEach(i => {symbolMap[i.json.symbol] = i.json}); const results = []; pairs.forEach(pair => {if (!symbolMap[pair.long] || !symbolMap[pair.short]) return; const z_score = Math.random() * 4 - 2; let signal = 0; if (z_score > 2) signal = -1; if (z_score < -2) signal = 1; if (signal !== 0) {results.push({json: {symbol: pair.long + '/' + pair.short, strategy_type: 'statistical_arbitrage', signal, signal_strength: Math.abs(z_score) / 3, z_score, momentum_score: 0, rsi: 50, realized_vol: 0.015, timestamp: new Date().toISOString()}})}}); return results;"
      }
    },
    {
      "name": "Merge All Signals",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [600, 50],
      "parameters": {
        "functionCode": "return items.map(item => {const sig = item.json; return {json: {...sig, recommended_size: (0.01 / sig.realized_vol) * Math.abs(sig.signal) * sig.signal_strength}};});"
      }
    },
    {
      "name": "Format Signals Output",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [800, 50],
      "parameters": {
        "mode": "manual",
        "assignments": {
          "assignments": [
            {
              "id": "0",
              "name": "signals",
              "type": "expression",
              "value": "={{$json}}"
            }
          ]
        }
      }
    },
    {
      "name": "Log Signals Generated",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1000, 50],
      "parameters": {
        "functionCode": "const count = items.length; console.log(`[SIGNALS] Generated ${count} trading signals at ${new Date().toISOString()}`); return [{json: {status: 'success', signals_generated: count, timestamp: new Date().toISOString()}}];"
      }
    }
  ],
  "connections": {
    "Trigger - Every 15 minutes": {
      "main": [[{"node": "Collect Market Data", "branch": 0, "index": 0}]]
    },
    "Collect Market Data": {
      "main": [[{"node": "Mean Reversion Signals", "branch": 0, "index": 0}, {"node": "Momentum Signals", "branch": 0, "index": 0}, {"node": "Statistical Arbitrage Signals", "branch": 0, "index": 0}]]
    },
    "Mean Reversion Signals": {
      "main": [[{"node": "Merge All Signals", "branch": 0, "index": 0}]]
    },
    "Momentum Signals": {
      "main": [[{"node": "Merge All Signals", "branch": 0, "index": 0}]]
    },
    "Statistical Arbitrage Signals": {
      "main": [[{"node": "Merge All Signals", "branch": 0, "index": 0}]]
    },
    "Merge All Signals": {
      "main": [[{"node": "Format Signals Output", "branch": 0, "index": 0}]]
    },
    "Format Signals Output": {
      "main": [[{"node": "Log Signals Generated", "branch": 0, "index": 0}]]
    }
  },
  "settings": {
    "saveExecutionProgress": true
  },
  "active": false
}
