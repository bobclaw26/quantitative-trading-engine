{
  "name": "Quantitative Trading Engine - Execution Engine",
  "nodes": [
    {
      "name": "Trigger - Every 30 minutes",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [0, 0],
      "parameters": {
        "cronExpression": "*/30 * * * *",
        "timezone": "UTC"
      }
    },
    {
      "name": "Load Current Positions",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 0],
      "parameters": {
        "dataTableName": "paper_positions",
        "mode": "select"
      }
    },
    {
      "name": "Load Active Signals",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 100],
      "parameters": {
        "dataTableName": "signals",
        "mode": "select",
        "orderBy": "timestamp DESC",
        "limit": 100
      }
    },
    {
      "name": "Load Current Prices",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 200],
      "parameters": {
        "dataTableName": "market_prices",
        "mode": "select",
        "orderBy": "timestamp DESC",
        "limit": 15
      }
    },
    {
      "name": "Load Portfolio State",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [200, 300],
      "parameters": {
        "dataTableName": "portfolio_summary",
        "mode": "select",
        "orderBy": "timestamp DESC",
        "limit": 1
      }
    },
    {
      "name": "Match Signals to Prices & Execute",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 100],
      "parameters": {
        "functionCode": "const positions = items[0]?.json ? [items[0].json] : [];\nconst signals = items.slice(1)?.map(s => s.json) || [];\nconst prices = items[2]?.json ? [items[2].json] : [];\nconst portfolio = items[3]?.json || { total_portfolio_value: 100000 };\nconst priceMap = {};\nprices.forEach(p => { priceMap[p.symbol] = parseFloat(p.close); });\nconst positionMap = {};\npositions.forEach(p => { positionMap[p.symbol] = p; });\nconst trades = [];\nconst timestamp = new Date().toISOString();\nconst capital = portfolio.total_portfolio_value * 0.01;\nsignals.forEach(sig => {\n  const symbol = sig.symbol;\n  const currentPrice = priceMap[symbol];\n  if (!currentPrice) return;\n  const existingPos = positionMap[symbol];\n  const position_size = capital / currentPrice * sig.signal_strength;\n  if (sig.signal === 1 && !existingPos) {\n    trades.push({symbol, side: 'BUY', quantity: Math.floor(position_size), price: currentPrice, strategy_type: sig.strategy_type, timestamp});\n  } else if (sig.signal === -1 && !existingPos) {\n    trades.push({symbol, side: 'SELL', quantity: Math.floor(position_size), price: currentPrice, strategy_type: sig.strategy_type, timestamp});\n  } else if (sig.signal === 0 && existingPos) {\n    trades.push({symbol, side: existingPos.quantity > 0 ? 'SELL' : 'BUY', quantity: Math.abs(existingPos.quantity), price: currentPrice, strategy_type: existingPos.strategy_type, timestamp});\n  }\n});\nreturn trades.map(t => ({json: t}));"
      }
    },
    {
      "name": "Update Positions & Log Trades",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [600, 100],
      "parameters": {
        "functionCode": "const positionUpdates = [];\nconst tradeLog = [];\nitems.forEach(item => {\n  const t = item.json;\n  tradeLog.push({symbol: t.symbol, side: t.side, quantity: t.quantity, price: t.price, pnl: 0, strategy_type: t.strategy_type, timestamp: t.timestamp});\n  if (t.side === 'BUY') {\n    positionUpdates.push({symbol: t.symbol, quantity: t.quantity, entry_price: t.price, current_price: t.price, unrealized_pnl: 0, position_value: t.quantity * t.price, strategy_type: t.strategy_type, entry_date: new Date().toISOString()});\n  } else if (t.side === 'SELL') {\n    positionUpdates.push({symbol: t.symbol + '_CLOSED', quantity: 0, entry_price: t.price, current_price: t.price, unrealized_pnl: 0, position_value: 0, strategy_type: t.strategy_type, entry_date: new Date().toISOString()});\n  }\n});\nreturn [{json: {positionUpdates, tradeLog}}];"
      }
    },
    {
      "name": "Insert Trade Log",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [800, 0],
      "parameters": {
        "dataTableName": "trade_log",
        "mode": "insert",
        "columns": ["symbol", "side", "quantity", "price", "pnl", "strategy_type", "timestamp"]
      }
    },
    {
      "name": "Update Positions Table",
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 2,
      "position": [800, 100],
      "parameters": {
        "dataTableName": "paper_positions",
        "mode": "upsert",
        "columns": ["symbol", "quantity", "entry_price", "current_price", "unrealized_pnl", "position_value", "strategy_type", "entry_date"]
      }
    },
    {
      "name": "Update Unrealized PnL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 100],
      "parameters": {
        "jsCode": "// Update current prices for all open positions\nconst prices = $('Load Current Prices').all();\nconst priceMap = {};\nprices.forEach(p => { priceMap[p.json.symbol] = p.json.close; });\n\nconst positions = $('Load Current Positions').all().map(p => p.json);\nreturn positions.map(pos => ({\n  symbol: pos.symbol,\n  quantity: pos.quantity,\n  entry_price: pos.entry_price,\n  current_price: priceMap[pos.symbol] || pos.current_price,\n  unrealized_pnl: (priceMap[pos.symbol] - pos.entry_price) * pos.quantity,\n  position_value: priceMap[pos.symbol] * pos.quantity,\n  strategy_type: pos.strategy_type,\n  entry_date: pos.entry_date\n}));"
      }
    }
  ],
  "connections": {
    "Trigger - Every 30 minutes": {
      "main": [[{ "node": "Load Current Positions", "branch": 0, "index": 0 }, { "node": "Load Active Signals", "branch": 0, "index": 0 }, { "node": "Load Current Prices", "branch": 0, "index": 0 }, { "node": "Load Portfolio State", "branch": 0, "index": 0 }]]
    },
    "Load Current Positions": {
      "main": [[{ "node": "Match Signals to Prices & Execute", "branch": 0, "index": 0 }]]
    },
    "Load Active Signals": {
      "main": [[{ "node": "Match Signals to Prices & Execute", "branch": 0, "index": 0 }]]
    },
    "Load Current Prices": {
      "main": [[{ "node": "Match Signals to Prices & Execute", "branch": 0, "index": 0 }, { "node": "Update Unrealized PnL", "branch": 0, "index": 0 }]]
    },
    "Load Portfolio State": {
      "main": [[{ "node": "Match Signals to Prices & Execute", "branch": 0, "index": 0 }]]
    },
    "Match Signals to Prices & Execute": {
      "main": [[{ "node": "Update Positions & Log Trades", "branch": 0, "index": 0 }]]
    },
    "Update Positions & Log Trades": {
      "main": [[{ "node": "Insert Trade Log", "branch": 0, "index": 0 }, { "node": "Update Positions Table", "branch": 0, "index": 0 }]]
    },
    "Update Positions Table": {
      "main": [[{ "node": "Update Unrealized PnL", "branch": 0, "index": 0 }]]
    }
  },
  "settings": {
    "saveExecutionProgress": true
  },
  "active": false
}
